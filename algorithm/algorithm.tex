% ------------------------------------------------
% Page start
% ------------------------------------------------
\chapter{Algorithm}
\label{chapter:algorithm}

\baselineskip=26pt
\thispagestyle{empty}
% ------------------------------------------------

\subsection{Design}

\subsubsection{Li's Hash}

Li's Hash is an algorithm that combines the concept of n-gram indexing \cite{web:wiki:n-gram} (Figure \ref{fig:algorithm:n-gram}), JSON (JavaScript Object Notation) \cite{web:wiki:json} (Figure \ref{fig:algorithm:json_example}) and hash table \cite{web:wiki:hash-table}.\\

JSON to store data which is exactly as same as hash table, but only different of the value's data type, which is because of the mapping design. And the n-gram indexing normally only target the data in string.\\

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{./algorithm/pic/json_example_v1.png}
%\includegraphics[width=0.4\textwidth]{./algorithm/pic/json_example_v1.png}
\caption{A example of JSON.}
\label{fig:algorithm:json_example}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{./algorithm/pic/n-gram_v1.png}
%\includegraphics[width=0.4\textwidth]{./algorithm/pic/n-gram_v1.png}
\caption{A example of n-gram indexing.}
\label{fig:algorithm:n-gram}
\end{figure}

Combining all of them can form a special indexing structure which can store the data and query different data type of data, which can very useful for all kind of query and storage system design.\\

Also because Li's Hash is just an algorithm, so it can easily to suit for all kind of key-value stores, or just swap the back-end database that can use another without change any front-end code.\\

%\clearpage

% Data type section
\subsubsection{Data type}

Li's Hash try to fellow KISS (Keep It Simple \& Stupid) principle for user, so Li's Hash will only provide few basic data type to replace the general data type in SQL database \cite{web:mysql:data-types,web:mysql:data-types-store-requirements,web:sqlite:data-types-3,web:transact-sql:data-types}, to decrease the time that user need to understand all kind of data type before writing the code, and can be ignore the range of data type, to let them focus on their system design.\\

The provided data type are \textit{STRING}, \textit{INTEGER}, \textit{REAL}, \textit{BOOLEAN} and \textit{BLOB}. Table \ref{table:algorithm:database-layer:code-example} shows part of data type comparison between Li's Hash and relational database.

Table \ref{table:algorithm:data_type_description} is the description that the storage size and range about each data type.\\

\begin{table}[h]
\centering
\caption{Data type comparison}
\label{table:algorithm:database-layer:code-example}
\begin{tabular}{|c|c|}

\hline
\multicolumn{1}{|c|}{\textbf{Li's Hash}} &
\multicolumn{1}{c|}{\textbf{Relational database}} \\

\hline
\multicolumn{1}{|c|}{STRING} &
\multicolumn{1}{c|}
{\tabincell{c}{
TEXT \\ CHAR \\ VARCHAR
}} \\

\hline
\multicolumn{1}{|c|}{BOOLEAN} &
\multicolumn{1}{c|}
{\tabincell{c}{
CHAR(1) \\ BOOLEAN
}} \\

\hline
\multicolumn{1}{|c|}{BLOB} &
\multicolumn{1}{c|}
{\tabincell{c}{
BLOB
}} \\

\hline
\multicolumn{1}{|c|}{INTEGER} &
\multicolumn{1}{c|}
{\tabincell{c}{
INT \\ INTEGER \\ BIGINT
}} \\

\hline
\multicolumn{1}{|c|}{REAL} &
\multicolumn{1}{c|}
{\tabincell{c}{
REAL \\ DOUBLE \\ FLOAT \\ DECIMAL
}} \\

\hline
\end{tabular}
\end{table}


\begin{table}[h]
\centering
\caption{Data type description}
\label{table:algorithm:data_type_description}
\begin{tabular}{|c|c|c|c|c|c|}

\hline
\multicolumn{1}{|c|}{Type name} &
\multicolumn{1}{c|}{STRING} &
\multicolumn{1}{c|}{BOOLEAN} &
\multicolumn{1}{c|}{INTEGER} &
\multicolumn{1}{c|}{REAL} &
\multicolumn{1}{c|}{BLOB} \\

\hline
\multicolumn{1}{|c|}{indexing} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{byte length (\textit{b})} &
\multicolumn{1}{c|}{dynamic} &
\multicolumn{1}{c|}{1} &
\multicolumn{1}{c|}{8} &
\multicolumn{1}{c|}{dynamic} &
\multicolumn{1}{c|}{dynamic} \\

\hline
\multicolumn{1}{|c|}{data range} &
\multicolumn{1}{c|}{-} &
\multicolumn{1}{c|}{0 $\thicksim$ 1} &
\multicolumn{1}{c|}{
\tabincell{c}
{0 $\thicksim 2^{64}$ - 1 \\ or \\-$2^{63} \thicksim 2^{63}$ - 1}} &
\multicolumn{1}{c|}{No limited} &
\multicolumn{1}{c|}{-} \\

\hline
\end{tabular}
\end{table}

Table \ref{table:algorithm:lishash_type_operation} shows what operation of each data type can do in Li's Hash.

\begin{table}[h]
\centering
\caption{Type of operation}
\label{table:algorithm:lishash_type_operation}
\begin{tabular}{|c|c|c|c|c|c|}

\hline
\multicolumn{1}{|c|}{Type name} &
\multicolumn{1}{c|}{STRING} &
\multicolumn{1}{c|}{BOOLEAN} &
\multicolumn{1}{c|}{INTEGER} &
\multicolumn{1}{c|}{REAL} &
\multicolumn{1}{c|}{BLOB} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{Search\\(Exact matching)}} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{Search\\(Prefix matching)}} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{Search\\(Suffix matching)}} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{Search\\(Partial matching)}} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Equal} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{Equal\\(muti-value)}} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Not equal} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{Not equal\\(muti-value)}} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Less than} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Less than or equal} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Greater than} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Greater than or equal} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\multicolumn{1}{|c|}{Between} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{N} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{Y} &
\multicolumn{1}{c|}{N} \\

\hline
\end{tabular}
\end{table}

And Table \ref{table:algorithm:data_type_represent_in_sql} is listed the data type will represent that data type in SQL database.

\begin{table}[h]
\centering
\caption{Data type represent in SQL database}
\label{table:algorithm:data_type_represent_in_sql}
\begin{tabular}{|c|c|c|c|c|c|}

\hline
\multicolumn{1}{|c|}{Type} &
\multicolumn{1}{c|}{STRING} &
\multicolumn{1}{c|}{BOOLEAN} &
\multicolumn{1}{c|}{INTEGER} &
\multicolumn{1}{c|}{REAL} &
\multicolumn{1}{c|}{BLOB} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{
MySQL\\
\cite{web:mysql:data-types,web:mysql:data-types-store-requirements}
}} &
\multicolumn{1}{c|}{\tabincell{c}{
VARCHAR \\ VARBINARY \\ CHAR \\ BINARY
}} &
\multicolumn{1}{c|}{\tabincell{c}{
CHAR(1) \\ BINARY(1) \\ TINYINT(1)
}} &
\multicolumn{1}{c|}{\tabincell{c}{
TINYINT \\ SMALLINT \\ MEDIUMINT \\ INT \\ INTEGER \\ BIGINT
}} &
\multicolumn{1}{c|}{\tabincell{c}{
FLOAT \\ DOUBLE \\ DECIMAL \\ NUMERIC
}} &
\multicolumn{1}{c|}{\tabincell{c}{
TINYBLOB \\ TINYTEXT \\ BLOB \\ TEXT \\ MEDIUMBLOB \\ MEDIUMTEXT \\ LONGBLOB \\ LONGTEXT
}} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{
SQLite\\
\cite{web:sqlite:data-types-3}
}} &
\multicolumn{1}{c|}{\tabincell{c}{
CHARACTER \\ VARCHAR \\ VARYING CHARACTER \\ NCHAR \\ NATIVE CHARACTER \\ NVARCHAR \\ TEXT \\ CLOB
}} &
\multicolumn{1}{c|}{\tabincell{c}{
BOOLEAN
}} &
\multicolumn{1}{c|}{\tabincell{c}{
INT \\ INTEGER \\ TINYINT \\ SMALLINT \\ MEDIUMINT \\ BIGINT \\ UNSIGNED BIG INT \\ INT2 \\ INT8 \\ NUMERIC
}} &
\multicolumn{1}{c|}{\tabincell{c}{
REAL \\ DOUBLE \\ FLOAT
}} &
\multicolumn{1}{c|}{\tabincell{c}{
BLOB
}} \\

\hline
\multicolumn{1}{|c|}{\tabincell{c}{
SQL server\\
\cite{web:transact-sql:data-types}
}} &
\multicolumn{1}{c|}{\tabincell{c}{
char \\ varchar \\ text \\ nchar \\ nvarchar \\ ntext
}} &
\multicolumn{1}{c|}{\tabincell{c}{
bit
}} &
\multicolumn{1}{c|}{\tabincell{c}{
bigint \\ numeric \\ smallint \\ decimal \\ smallmoney \\ int \\ tinyint \\ money
}} &
\multicolumn{1}{c|}{\tabincell{c}{
float \\ real
}} &
\multicolumn{1}{c|}{\tabincell{c}{
binary \\ varbinary \\ image
}} \\

\hline
\end{tabular}
\end{table}

\clearpage

% Index table section
\subsubsection{Index table}

To make the data queryable, Li's Hash design a custom indexing for each data type, so that each data type has their own index tables. The index table is the core concept of Li's Hash. The tables are JSON objects design, there are two kind of index table, \textit{"Index table"} and \textit{"Invert index table"}. Figure \ref{fig:algorithm:lishash_example} is shows the example that the tables looks like contain data \textit{"cow"} with the data type \textit{STRING} which will have more detail later.\\

The tables are using the multi-gram indexing but one table is use the invert way to do the indexing as its name. Because the table is a JSON object, so it is a name-value design, the \textit{"value"} is a collection which means it can store everything no matter an array or a data. In Li's Hash, the \textit{"value"} is pointing to a array which will contain element or data node, but for easy visualization that the array will using a list to show on figure, so call it as \textit{"Bucket"} is quite suitable. This means the index table in Li's Hash as a \textit{"name-bucket"} format.\\

Each element node contain few metadata: the value of this node storing (value), the count of this node is be using (count), and the count of the value repeating (repeat). The data nodes is pointing to the data \textit{id} of the data record.

\begin{figure}[h]
\centering
%\includegraphics[scale=0.4]{./algorithm/pic/index_table/table_format_v13.pdf}
\includegraphics[width=0.8\textwidth]{./algorithm/pic/index_table/table_format_v13.pdf}
\caption{A example of Li's Hash.}
\label{fig:algorithm:lishash_example}
\end{figure}

The time complexity of initial the tables is $O(1)$. About the meanings of all tables, which will more clearly in each operation of all data type.

\clearpage

% STRING section
\input{./algorithm/string/string.tex}

% BOOLEAN section
\input{./algorithm/boolean/boolean.tex}

% INTEGER section
\input{./algorithm/integer/integer.tex}

% REAL section
\input{./algorithm/real/real.tex}

% BLOB section
\input{./algorithm/blob/blob.tex}

\clearpage

% Summary and case study section
\input{./algorithm/summary.tex}

\clearpage

% ------------------------------------------------
% End of page
% ------------------------------------------------
