\subsection{REAL type}

From 1960, there are many computer company has they own design of floating point, this cause a huge problem in data exchange andcommunication, this bring out the standard of IEEE 754 \cite{web:wiki:ieee-754}. Because of the hardware design, if want to have a range of the data, then it need to sacrifice the accuracy, this called the "Round-off error" \cite{web:wiki:round-off_error,web:c:handle-round-off_error}.\\

That's why the IEEE 754 specific the best between range and the accuracy, but still it can't provide 100\% accuracy, also the design of IEEE 754 is not suitable for do the operation like sorting and comparison. So if want to handle the data as a floating point, then this need to jump out from the IEEE 754, and building the own data structure. Then this can store the data no matter how big it is with 100\% accuracy, but this cost a little more space.\\

We study the design and description of $float$ and $double$ design from some of the existing relational database \cite{web:wiki:floating_point,web:wiki:double-precision_floating-point_format,web:wiki:real-number,web:vcpp:data-type-ranges,web:wiki:c-data-types,web:c:data-types,web:transact-sql:int-bigint-smallint-tinyint,web:transact-sql:effective_number_of_bits-decimal_places-length,web:transact-sql:float-real,web:csharp:decimal,web:sql-server:decimal-float-real,web:c-cpp:floating-point-precision,web:mysql:query-sorting-numbers,web:mysql:using-decimal-to-record-float-point,web:mysql:sql-manual-reference}. In these database, they usually design a data type as \textit{"Decimal"} to handle the problem of IEEE 754.\\

\textit{"Decimal"} is a unpack floating point which contain the sign, and the number are store as a string, this means each number will consume a byte to record it. When need to do sorting or comparison operation, it will need to read the data and convert it into string first, this means it need cost one more step before the process.\\

So if fellow the \textit{"Decimal"} design to handle the floating point, this will cost more spaces. Such as if store "100" as \textit{"Decimal"} type which will as cost 3 bytes ('1', '0', '0'), but if using the character type (char) to store it which just need 1 byte ('d' in ASCII). Also we want the Li's Hash can use the index table can do the sorting or comparison, so we create a data type as \textit{REAL} to handle the problem above.\\

\textit{REAL} (aka the \textit{"real number"} in mathematics \cite{web:wiki:real-number}) is combine the concept of \textit{"Decimal"} and design of $INTEGER$. First convert the floating point into string when inputting the value, then partition it into three part to store as figure \ref{fig:algorithm:real:data_format}: \textit{"Sign"}, \textit{"Integer"}, \textit{"Decimal"}. After that convert \textit{"Integer"} and \textit{"Decimal"} part back into bytes by using base256, so this can use less byte to store the value, also this can use the design in $INTEGER$ to do indexing, so that \textit{REAL} can also do sorting or comparison operation. Also becuase need keep the accuracy of the value, so the length of byte usage is dynamic.\\

\begin{figure}[h]
\centering
%\includegraphics[scale=1.0]{./algorithm/real/pic/design/data_format_v3.pdf}
\includegraphics[width=0.6\textwidth]{./algorithm/real/pic/design/data_format_v3.pdf}
\caption{Data format of \textit{REAL} type.}
\label{fig:algorithm:real:data_format}
\end{figure}

The data format (figure \ref{fig:algorithm:real:data_format}) of \textit{REAL} is little bit different than the normal data concept, the value is as same as normal, the number at the left hand side means larger.\\

But when in the storage view is different, the \textit{"Integer"} part is store in normal and inverted order which will explain in the example of each operation, but the \textit{"Decimal"} part is using inverted which means the value will inverted when it stored. We use figure \ref{fig:algorithm:real:data_store_inverted} to explain why we do this.

\begin{figure}[h]
\centering
    \begin{subfigure}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{./algorithm/real/pic/design/data_store_inverted_1_v1.pdf}
        \caption{Normal order}
        \label{fig:algorithm:real:data_store_inverted_1}
    \end{subfigure}%
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{./algorithm/real/pic/design/data_store_inverted_2_v1.pdf}
        \caption{Inverted order}
        \label{fig:algorithm:real:data_store_inverted_2}
    \end{subfigure}

    \caption{Value storage}
    \label{fig:algorithm:real:data_store_inverted}
\end{figure}

If the data store as the same order as usual, the sample data will store like figure \ref{fig:algorithm:real:data_store_inverted_1}, the problem is if we treat \textit{'01'} as a value, it will convert into \textit{'1'} and lost its owns meaning, because \textit{'.1'} is not equal \textit{'.01'}. So if invert the \textit{"Decimal"} part, the value will look like figure \ref{fig:algorithm:real:data_store_inverted_2}. It shows the value can be store without missing value, the only is a additional convert operation is need to revert back into the real value when return data.\\

\begin{figure}[h]
\centering
%\includegraphics[scale=1.0]{./algorithm/real/pic/design/example_v4.pdf}
\includegraphics[width=0.8\textwidth]{./algorithm/real/pic/design/example_v4.pdf}
\caption{The index tables of \textit{REAL} type.}
\label{fig:algorithm:real:example}
\end{figure}

Figure \ref{fig:algorithm:real:example} is the example when storing data into index table. This table start with $root$ which is pointing to the \textit{"Sign"} part which is store with the last byte of \textit{"Integer"} part.

The \textit{"Integer"} is indexing using n-gram as normal, but it will index in two way:

\begin{enumerate}

\item When indexing the \textit{"Integer"} part only (like $'$+$\backslash44\backslash1'$ in figure), it is start from the last byte to the first, and then will pointing to the element node which contain a flag that means as $decimal$, which is represent to begin \textit{"Decimal"} part.

\item Like $'$+$\backslash1\backslash44\_\backslash2\backslash142'$ in figure, the order of the \textit{"Integer"} part is store as from the left to right when it is storing with the \textit{"Decimal"} part.

\end{enumerate}

And \textit{"Decimal"} is store from right to left, and because the inverted string value design which means if the value is small then it will become a greater value.

This order of \textit{"Integer"} and \textit{"Decimal"} part design is because this can do faster searching the key when doing sorting and comparison, this will explan detail in fellowing section.

% Insertion section
\input{./algorithm/real/insertion.tex}

% Deletion section
\input{./algorithm/real/deletion.tex}

% Modification section
\input{./algorithm/real/modification.tex}

% Selection section
\input{./algorithm/real/selection.tex}

% Summary section
\input{./algorithm/real/summary.tex}

\clearpage

